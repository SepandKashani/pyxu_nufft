# This is a template file used by `_spread.py`.
# Dollar-enclosed variables are replaced at runtime.


import numba as nb
import numba.types as nbt
import numpy as np

f_flags = dict(
    nopython=True,
    nogil=True,
    cache=True,
    forceobj=False,
    parallel=False,
    error_model="numpy",
    fastmath=True,
    locals={},
    boundscheck=False,
)

@nb.jit(**f_flags)
def find_bounds(x: np.ndarray[float]) -> tuple[int, int]:
    # Parameters:
    #     x: (N,)
    # Returns
    #     a, b: indices s.t. x[a:b] contains the non-zero segment of `x`.
    N = len(x)
    a, a_found = N, False
    b, b_found = N, False
    for i in range(N):
        lhs, rhs = x[i], x[N - 1 - i]
        if (not a_found) and (abs(lhs) > 0):
            a, a_found = i, True
        if (not b_found) and (abs(rhs) > 0):
            b, b_found = N - i, True
        if a_found and b_found:  # early exit
            return a, b
    return a, b

@nb.jit(
    "${signature_spread}",
    **f_flags,
)
def f_spread(
    w: np.ndarray[float],  # C-(M, Ns)
    kernel: np.ndarray[float],  # C-(M, S_max, D)
    out: np.ndarray[float],  # C-(S1,...,SD, Ns)
):
    M, Ns = w.shape
    D = ${dim_rank}
    S = out.shape[:${dim_rank}]

    lb = np.zeros(D, dtype=np.int64)
    ub = np.zeros(D, dtype=np.int64)
    for m in range(M):
        for d in range(D):
            lb[d], ub[d] = find_bounds(kernel[m, : S[d], d])

        support = ${support}
        for offset in np.ndindex(support):
            idx = ${idx}

            # Compute kernel weight
            k = 1
            for d in range(D):
                k *= kernel[m, idx[d], d]

            # Spread onto lattice
            for ns in range(Ns):
                out[*idx, ns] += k * w[m, ns]

@nb.jit(
    "${signature_interpolate}",
    **f_flags,
)
def f_interpolate(
    v: np.ndarray[float],  # C-(S1,...,SD, Ns)
    kernel: np.ndarray[float],  # C-(M, S_max, D)
    out: np.ndarray[float],  # C-(M, Ns)
):
    M, Ns = out.shape
    D = ${dim_rank}
    S = v.shape[:${dim_rank}]

    lb = np.zeros(D, dtype=np.int64)
    ub = np.zeros(D, dtype=np.int64)
    for m in range(M):
        for d in range(D):
            lb[d], ub[d] = find_bounds(kernel[m, : S[d], d])

        support = ${support}
        for offset in np.ndindex(support):
            idx = ${idx}

            # Compute kernel weight
            k = 1
            for d in range(D):
                k *= kernel[m, idx[d], d]

            # Spread onto support point
            for ns in range(Ns):
                out[m, ns] += k * v[*idx, ns]
